"""Bundled Flashy core modules for Pyodide.

This file is auto-generated by build.py
Do not edit directly!
"""

import sys
from types import ModuleType

# Create package structure
def create_package(name):
    """Create a package and all parent packages."""
    parts = name.split(".")
    for i in range(len(parts)):
        pkg_name = ".".join(parts[:i+1])
        if pkg_name not in sys.modules:
            pkg = ModuleType(pkg_name)
            pkg.__path__ = []
            pkg.__package__ = pkg_name
            sys.modules[pkg_name] = pkg
            # Add to parent
            if i > 0:
                parent_name = ".".join(parts[:i])
                setattr(sys.modules[parent_name], parts[i], pkg)

# Create all packages
create_package("flashy")
create_package("flashy.core")
create_package("flashy.platforms")
create_package("flashy.platforms.web")
create_package("flashy.storage")

# === flashy.core.models ===
# Create module
_mod = ModuleType("flashy.core.models")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.models"] = _mod
setattr(sys.modules["flashy.core"], "models", _mod)

_code_flashy_core_models = """\
\"\"\"Data models for game state - pure data, no I/O.\"\"\"

from dataclasses import dataclass, field


@dataclass
class PlayerProgress:
    \"\"\"Player's game progress - stars and unlocked levels.\"\"\"

    stars: dict[int, int] = field(default_factory=dict)  # level_number -> stars (1-3)

    def get_stars(self, level: int) -> int:
        \"\"\"Get stars for a level (0 if not completed).\"\"\"
        return self.stars.get(level, 0)

    def set_stars(self, level: int, stars: int) -> None:
        \"\"\"Set stars for a level, keeping the best score.\"\"\"
        current = self.stars.get(level, 0)
        if stars > current:
            self.stars[level] = stars

    def get_highest_unlocked(self) -> int:
        \"\"\"Get the highest level that has been unlocked.\"\"\"
        if not self.stars:
            return 1  # Start with level 1 unlocked

        # Find highest completed level with 2+ stars
        highest = 0
        for level_num, star_count in self.stars.items():
            if star_count >= 2:
                highest = max(highest, level_num)

        # Next level after highest completed is unlocked
        return highest + 1

    def is_unlocked(self, level: int) -> bool:
        \"\"\"Check if a level is unlocked (playable).\"\"\"
        if level == 1:
            return True
        # Level is unlocked if previous level has 2+ stars
        return self.get_stars(level - 1) >= 2


@dataclass
class ProblemResult:
    \"\"\"Result of a single problem attempt.\"\"\"

    problem: str
    correct_answer: int
    given_answer: int | None
    is_correct: bool
    time_seconds: float
    points: int


@dataclass
class LevelResult:
    \"\"\"Result of completing a level.\"\"\"

    level_number: int
    level_name: str
    total_score: int
    correct_count: int
    total_problems: int
    best_streak: int
    total_time_seconds: float
    problems: list[ProblemResult]

"""

exec(_code_flashy_core_models, sys.modules["flashy.core.models"].__dict__)

# === flashy.core.problems ===
# Create module
_mod = ModuleType("flashy.core.problems")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.problems"] = _mod
setattr(sys.modules["flashy.core"], "problems", _mod)

_code_flashy_core_problems = """\
\"\"\"Problem generation - pure functions for creating math problems.\"\"\"

import random
from dataclasses import dataclass
from enum import Enum


class Operation(Enum):
    ADD = "+"
    SUBTRACT = "-"
    MULTIPLY = "x"
    DIVIDE = "/"


@dataclass(frozen=True)
class Problem:
    \"\"\"A math problem with two operands and an operation.\"\"\"

    operand1: int
    operand2: int
    operation: Operation
    answer: int

    def display(self) -> str:
        \"\"\"Return the problem as a string for display.\"\"\"
        return f"{self.operand1} {self.operation.value} {self.operand2}"


def generate_problem(operation: Operation, min_val: int, max_val: int) -> Problem:
    \"\"\"Generate a random problem for the given operation and number range.

    For subtraction: ensures non-negative result.
    For division: ensures clean integer result (no remainder).
    \"\"\"
    if operation == Operation.ADD:
        return _generate_addition(min_val, max_val)
    elif operation == Operation.SUBTRACT:
        return _generate_subtraction(min_val, max_val)
    elif operation == Operation.MULTIPLY:
        return _generate_multiplication(min_val, max_val)
    elif operation == Operation.DIVIDE:
        return _generate_division(min_val, max_val)
    else:
        raise ValueError(f"Unknown operation: {operation}")


def _generate_addition(min_val: int, max_val: int) -> Problem:
    a = random.randint(min_val, max_val)
    b = random.randint(min_val, max_val)
    return Problem(operand1=a, operand2=b, operation=Operation.ADD, answer=a + b)


def _generate_subtraction(min_val: int, max_val: int) -> Problem:
    # Generate two numbers and ensure a >= b for non-negative result
    a = random.randint(min_val, max_val)
    b = random.randint(min_val, max_val)
    if a < b:
        a, b = b, a
    return Problem(operand1=a, operand2=b, operation=Operation.SUBTRACT, answer=a - b)


def _generate_multiplication(min_val: int, max_val: int) -> Problem:
    a = random.randint(min_val, max_val)
    b = random.randint(min_val, max_val)
    return Problem(operand1=a, operand2=b, operation=Operation.MULTIPLY, answer=a * b)


def _generate_division(min_val: int, max_val: int) -> Problem:
    # Generate answer and divisor, then compute dividend
    # This ensures clean integer division
    answer = random.randint(min_val, max_val)
    divisor = random.randint(min_val, max_val)
    # Avoid division by zero
    if divisor == 0:
        divisor = 1
    dividend = answer * divisor
    return Problem(
        operand1=dividend, operand2=divisor, operation=Operation.DIVIDE, answer=answer
    )

"""

exec(_code_flashy_core_problems, sys.modules["flashy.core.problems"].__dict__)

# === flashy.core.scoring ===
# Create module
_mod = ModuleType("flashy.core.scoring")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.scoring"] = _mod
setattr(sys.modules["flashy.core"], "scoring", _mod)

_code_flashy_core_scoring = """\
\"\"\"Score calculation - pure functions for computing points.\"\"\"

# Base points for a correct answer
BASE_POINTS = 100

# Time thresholds for speed bonus (in seconds)
FAST_THRESHOLD = 2.0  # Under 2 seconds = fast
MEDIUM_THRESHOLD = 5.0  # Under 5 seconds = medium

# Speed bonus multipliers
FAST_BONUS = 1.5
MEDIUM_BONUS = 1.2

# Streak multipliers
STREAK_THRESHOLDS = [
    (3, 1.5),  # 3+ streak = 1.5x
    (5, 2.0),  # 5+ streak = 2x
    (10, 3.0),  # 10+ streak = 3x
]


def calculate_score(time_taken: float, is_correct: bool, streak: int) -> int:
    \"\"\"Calculate points for a single problem.

    Args:
        time_taken: Time in seconds to answer
        is_correct: Whether the answer was correct
        streak: Current streak count (consecutive correct answers)

    Returns:
        Points earned (0 if incorrect)
    \"\"\"
    if not is_correct:
        return 0

    points = float(BASE_POINTS)

    # Apply speed bonus
    if time_taken < FAST_THRESHOLD:
        points *= FAST_BONUS
    elif time_taken < MEDIUM_THRESHOLD:
        points *= MEDIUM_BONUS

    # Apply streak multiplier
    streak_multiplier = get_streak_multiplier(streak)
    points *= streak_multiplier

    return int(points)


def get_streak_multiplier(streak: int) -> float:
    \"\"\"Get the multiplier for the current streak.\"\"\"
    multiplier = 1.0
    for threshold, mult in STREAK_THRESHOLDS:
        if streak >= threshold:
            multiplier = mult
    return multiplier


# Star thresholds
STAR_3_ACCURACY = 1.0  # 100% correct
STAR_3_TIME_PER_PROBLEM = 5.0  # Average under 5 seconds per problem
STAR_2_ACCURACY = 0.8  # 80% correct
STAR_1_ACCURACY = 0.6  # 60% correct


def calculate_stars(
    correct: int,
    total: int,
    total_time: float,
) -> int:
    \"\"\"Calculate stars earned for a level.

    Args:
        correct: Number of correct answers
        total: Total number of problems
        total_time: Total time taken in seconds

    Returns:
        Stars earned (0-3)
        - 3 stars: 100% correct AND fast (under 5s per problem average)
        - 2 stars: 80%+ correct OR 100% correct but slow
        - 1 star: 60%+ correct
        - 0 stars: Below 60% (level not passed)
    \"\"\"
    if total == 0:
        return 0

    accuracy = correct / total
    avg_time = total_time / total

    # 3 stars: perfect AND fast
    if accuracy >= STAR_3_ACCURACY and avg_time <= STAR_3_TIME_PER_PROBLEM:
        return 3

    # 2 stars: 80%+ OR perfect but slow
    if accuracy >= STAR_2_ACCURACY or accuracy >= STAR_3_ACCURACY:
        return 2

    # 1 star: 60%+
    if accuracy >= STAR_1_ACCURACY:
        return 1

    # 0 stars: below 60%
    return 0

"""

exec(_code_flashy_core_scoring, sys.modules["flashy.core.scoring"].__dict__)

# === flashy.core.number_parser ===
# Create module
_mod = ModuleType("flashy.core.number_parser")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.number_parser"] = _mod
setattr(sys.modules["flashy.core"], "number_parser", _mod)

_code_flashy_core_number_parser = """\
\"\"\"Parse spoken numbers to integers.\"\"\"

import re

# Word to number mappings
ONES = {
    "zero": 0,
    "one": 1,
    "two": 2,
    "three": 3,
    "free": 3,  # often misheard as "three"
    "four": 4,
    "five": 5,
    "six": 6,
    "seven": 7,
    "eight": 8,
    "nine": 9,
    "ten": 10,
    "eleven": 11,
    "twelve": 12,
    "thirteen": 13,
    "fourteen": 14,
    "fifteen": 15,
    "sixteen": 16,
    "seventeen": 17,
    "eighteen": 18,
    "nineteen": 19,
}

TENS = {
    "twenty": 20,
    "thirty": 30,
    "forty": 40,
    "fifty": 50,
    "sixty": 60,
    "seventy": 70,
    "eighty": 80,
    "ninety": 90,
}

# Commonly confused number pairs (teens vs tens)
FUZZY_PAIRS = frozenset([
    (13, 30),  # thirteen / thirty
    (14, 40),  # fourteen / forty
    (15, 50),  # fifteen / fifty
    (16, 60),  # sixteen / sixty
    (17, 70),  # seventeen / seventy
    (18, 80),  # eighteen / eighty
    (19, 90),  # nineteen / ninety
])

# Digits that are commonly confused by speech recognition
# three (3) is often heard as four (4)
CONFUSED_DIGITS = {3: 4, 4: 3}

# Word-level confusions that cause structural changes
# "three" is often heard as "forty" (e.g., "three hundred" -> "forty hundred")
# This maps (recognized, expected) pairs that should be considered equivalent
CONFUSED_WORD_REPLACEMENTS = [
    (40, 3),  # "forty" misheard for "three"
]

# Give up phrases (include variants without apostrophes)
GIVE_UP_PHRASES = frozenset(
    [
        "give up",
        "skip",
        "pass",
        "i don t know",
        "i dont know",
        "next",
        "i give up",
    ]
)


def parse_spoken_number(text: str) -> int | None:
    \"\"\"Parse a spoken number string to an integer.

    Handles:
    - Single digits: "five" -> 5
    - Teens: "thirteen" -> 13
    - Tens: "twenty" -> 20
    - Compound: "twenty three" -> 23
    - Hundreds: "one hundred" -> 100, "one hundred twenty three" -> 123
    - Raw digits: "42" -> 42

    Returns None if no valid number found.
    \"\"\"
    if not text:
        return None

    # Normalize: lowercase, strip extra whitespace/punctuation
    text = text.lower().strip()
    text = re.sub(r"[^\\w\\s]", " ", text)  # Replace punctuation with space
    text = re.sub(r"\\s+", " ", text).strip()  # Normalize whitespace

    # Try parsing as raw integer first (Vosk sometimes outputs digits)
    try:
        return int(text)
    except ValueError:
        pass

    # Try to find a number in the text
    words = text.split()

    # Try parsing the full phrase, then progressively shorter suffixes
    # This handles cases like "the answer is twenty three"
    for start in range(len(words)):
        result = _parse_number_words(words[start:])
        if result is not None:
            return result

    return None


def _parse_number_words(words: list[str]) -> int | None:
    \"\"\"Parse a list of words as a number.\"\"\"
    if not words:
        return None

    total = 0
    current = 0
    found_number = False
    is_negative = False

    i = 0
    while i < len(words):
        word = words[i]

        if word in ("minus", "negative") and not found_number:
            is_negative = True
        elif word in ONES:
            current += ONES[word]
            found_number = True
        elif word in TENS:
            current += TENS[word]
            found_number = True
        elif word == "hundred":
            if current == 0:
                current = 1
            current *= 100
            found_number = True
        elif word == "and":
            # Skip "and" (e.g., "one hundred and twenty")
            pass
        else:
            # Unknown word - if we found a number, stop here
            if found_number:
                break
            # Otherwise, this isn't a number phrase
            return None

        i += 1

    if found_number:
        result = total + current
        return -result if is_negative else result
    return None


def is_give_up(text: str) -> bool:
    \"\"\"Check if the text is a give-up phrase.\"\"\"
    if not text:
        return False

    text = text.lower().strip()
    text = re.sub(r"[^\\w\\s]", " ", text)  # Replace punctuation with space
    text = re.sub(r"\\s+", " ", text).strip()  # Normalize whitespace

    return text in GIVE_UP_PHRASES


def _differs_by_confused_digit(recognized: int, expected: int) -> bool:
    \"\"\"Check if two numbers differ only by a single confused digit swap.

    For example, 43 vs 44 (three heard as four), or 73 vs 74.
    \"\"\"
    rec_str = str(recognized)
    exp_str = str(expected)

    if len(rec_str) != len(exp_str):
        return False

    diff_count = 0
    for r, e in zip(rec_str, exp_str, strict=True):
        if r != e:
            diff_count += 1
            if diff_count > 1:
                return False
            # Check if this is a confused digit pair
            r_digit, e_digit = int(r), int(e)
            if CONFUSED_DIGITS.get(e_digit) != r_digit:
                return False

    return diff_count == 1


def _matches_with_word_replacement(recognized: int, expected: int) -> bool:
    \"\"\"Check if recognized matches expected after applying word-level replacements.

    Handles cases like "three hundred forty two" -> "forty hundred forty two"
    where "three" (3) was heard as "forty" (40).
    \"\"\"
    for confused_val, correct_val in CONFUSED_WORD_REPLACEMENTS:
        # Try replacing the confused value with the correct value in recognized
        # e.g., 4042 with (40->3) replacement: 4042 -> 342
        rec_str = str(recognized)
        confused_str = str(confused_val)
        correct_str = str(correct_val)

        # Try replacing first occurrence
        if confused_str in rec_str:
            fixed = rec_str.replace(confused_str, correct_str, 1)
            try:
                if int(fixed) == expected:
                    return True
            except ValueError:
                pass

    return False


def is_fuzzy_match(recognized: int | None, expected: int) -> bool:
    \"\"\"Check if recognized number is a fuzzy match for expected.

    Accepts commonly confused pairs like fifteen/fifty,
    numbers that differ by confused digits (e.g., 43 vs 44 for three/four),
    and word-level confusions (e.g., 4042 vs 342 for "forty" misheard as "three").
    \"\"\"
    if recognized is None:
        return False

    if recognized == expected:
        return True

    # Check if they're a confused pair (teens vs tens)
    pair = (min(recognized, expected), max(recognized, expected))
    if pair in FUZZY_PAIRS:
        return True

    # Check if they differ by a confused digit (e.g., three/four)
    if _differs_by_confused_digit(recognized, expected):
        return True

    # Check for word-level replacements (e.g., "three" -> "forty")
    return _matches_with_word_replacement(recognized, expected)

"""

exec(_code_flashy_core_number_parser, sys.modules["flashy.core.number_parser"].__dict__)

# === flashy.core.worlds ===
# Create module
_mod = ModuleType("flashy.core.worlds")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.worlds"] = _mod
setattr(sys.modules["flashy.core"], "worlds", _mod)

_code_flashy_core_worlds = """\
\"\"\"World definitions - story content and theming.\"\"\"

from dataclasses import dataclass

from flashy.core.problems import Operation


@dataclass(frozen=True)
class World:
    \"\"\"Configuration for a game world.\"\"\"

    number: int
    name: str
    theme_emoji: str
    operation: Operation
    friend_name: str
    friend_emoji: str
    boss_name: str
    boss_emoji: str
    intro_text: str
    friend_text: str
    boss_intro: str
    boss_defeat: str


# World definitions
WORLD_1 = World(
    number=1,
    name="Addition Alps",
    theme_emoji="ðŸ”ï¸",
    operation=Operation.ADD,
    friend_name="Carry",
    friend_emoji="ðŸ¦‰",
    boss_name="Summit",
    boss_emoji="ðŸ",
    intro_text=(
        "Flashy woke up alone in the cold mountains.\\n"
        '"Where am I? I need to find my way home!"\\n'
        "The only way forward is up through the Addition Alps..."
    ),
    friend_text=(
        '"Hoo-hoo! I\\'m Carry the Owl!"\\n'
        '"I\\'ve watched many travelers climb these peaks."\\n'
        '"Remember: when numbers get big, just carry on!"\\n'
        '"Let me help you on your journey home."'
    ),
    boss_intro=(
        '"So, little pup, you think you can cross MY mountain?"\\n'
        '"I am Summit, guardian of the Alps!"\\n'
        '"Prove your addition skills... if you can keep up!"'
    ),
    boss_defeat=(
        '"Impressive, little one! You\\'ve earned passage."\\n'
        '"The path ahead leads to the Subtraction Swamp."\\n'
        '"May your numbers stay strong!"'
    ),
)

WORLD_2 = World(
    number=2,
    name="Subtraction Swamp",
    theme_emoji="ðŸŒ¿",
    operation=Operation.SUBTRACT,
    friend_name="Borrow",
    friend_emoji="ðŸ¢",
    boss_name="Minus",
    boss_emoji="ðŸ¸",
    intro_text=(
        "The mountains gave way to murky wetlands.\\n"
        '"It\\'s so foggy here... but I must keep going!"\\n'
        "Flashy stepped carefully into the Subtraction Swamp..."
    ),
    friend_text=(
        '"Slow down there, young pup!"\\n'
        '"I\\'m Borrow the Turtle. I\\'ve lived here for centuries."\\n'
        '"When you need to take away more than you have,"\\n'
        '"just borrow from your neighbor. Works every time!"'
    ),
    boss_intro=(
        '"RIBBIT! Who dares enter my swamp?"\\n'
        '"I am Minus, the Frog King!"\\n'
        '"Let\\'s see if you can subtract as fast as I can jump!"'
    ),
    boss_defeat=(
        '"RIBBIT... you\\'ve bested me, small one."\\n'
        '"The desert lies ahead. Stay hydrated!"\\n'
        '"Hop along now!"'
    ),
)

WORLD_3 = World(
    number=3,
    name="Division Desert",
    theme_emoji="ðŸœï¸",
    operation=Operation.DIVIDE,
    friend_name="Remainder",
    friend_emoji="ðŸª",
    boss_name="The Sphinx of Splits",
    boss_emoji="ðŸ¦",
    intro_text=(
        "The heat hit Flashy like a wall.\\n"
        '"So hot... but I can see green meadows in the distance!"\\n'
        "The Division Desert stretched endlessly before..."
    ),
    friend_text=(
        '"Ah, a traveler! I am Remainder the Camel."\\n'
        '"I carry what\\'s left over from every division."\\n'
        '"Remember: divide means to share equally!"\\n'
        '"Split it up fair, and you\\'ll find your answer."'
    ),
    boss_intro=(
        '"HALT, wanderer! None pass without solving my riddles."\\n'
        '"I am the Sphinx of Splits!"\\n'
        '"Divide correctly, or be lost to the sands forever!"'
    ),
    boss_defeat=(
        '"You have wisdom beyond your years, young pup."\\n'
        '"The meadows await. Your home draws near."\\n'
        '"Go forth with my blessing."'
    ),
)

WORLD_4 = World(
    number=4,
    name="Multiplication Meadows",
    theme_emoji="ðŸŒ¸",
    operation=Operation.MULTIPLY,
    friend_name="Times",
    friend_emoji="ðŸ°",
    boss_name="Countess Calculata",
    boss_emoji="ðŸ¦Š",
    intro_text=(
        "Beautiful flowers swayed in the breeze.\\n"
        '"I can almost smell home! It must be close!"\\n'
        "The Multiplication Meadows bloomed with possibility..."
    ),
    friend_text=(
        '"Oh my, oh my! A visitor!" *hops excitedly*\\n'
        '"I\\'m Times the Rabbit! I multiply EVERYTHING!"\\n'
        '"One carrot becomes two, two become four!"\\n'
        '"Multiplication is just fast addition, you know!"'
    ),
    boss_intro=(
        '"Well, well... the lost puppy finally arrives."\\n'
        '"I am Countess Calculata, master of all operations!"\\n'
        '"Beat me, and you\\'ll find your way home at last!"'
    ),
    boss_defeat=(
        '"Magnificent! You\\'ve mastered it all!"\\n'
        '"Look there, beyond the meadow..."\\n'
        '"Is that... your HOME?"'
    ),
)

WORLDS = [WORLD_1, WORLD_2, WORLD_3, WORLD_4]


def get_world(world_num: int) -> World | None:
    \"\"\"Get world by number. Returns None if world doesn't exist.\"\"\"
    for world in WORLDS:
        if world.number == world_num:
            return world
    return None

"""

exec(_code_flashy_core_worlds, sys.modules["flashy.core.worlds"].__dict__)

# === flashy.core.levels ===
# Create module
_mod = ModuleType("flashy.core.levels")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.levels"] = _mod
setattr(sys.modules["flashy.core"], "levels", _mod)

_code_flashy_core_levels = """\
\"\"\"Level definitions - curated problem sequences for each level.\"\"\"

from dataclasses import dataclass
from enum import Enum

from flashy.core.problems import Operation, Problem


class LevelType(Enum):
    \"\"\"Type of level determining its role in the world.\"\"\"

    INTRO = "intro"  # Easy warmup levels (1-3)
    BUILD = "build"  # Building difficulty (4-5)
    FRIEND = "friend"  # Meet a friend, story moment (6)
    CHALLENGE = "challenge"  # Harder levels (7-8)
    PREBOSS = "preboss"  # Tough preparation (9)
    BOSS = "boss"  # Timed boss battle (10)


@dataclass(frozen=True)
class Level:
    \"\"\"Configuration for a game level with curated problems.\"\"\"

    number: int  # Global level number (1-40)
    world_number: int  # Which world (1-4)
    level_in_world: int  # Position in world (1-10)
    name: str
    level_type: LevelType
    problems: tuple[Problem, ...]  # Curated problem sequence
    time_limit: int | None = None  # Seconds, only for boss levels


# Helper functions to create problems concisely
def add(a: int, b: int) -> Problem:
    \"\"\"Create an addition problem.\"\"\"
    return Problem(a, b, Operation.ADD, a + b)


def sub(a: int, b: int) -> Problem:
    \"\"\"Create a subtraction problem (a - b).\"\"\"
    return Problem(a, b, Operation.SUBTRACT, a - b)


def mul(a: int, b: int) -> Problem:
    \"\"\"Create a multiplication problem.\"\"\"
    return Problem(a, b, Operation.MULTIPLY, a * b)


def div(a: int, b: int) -> Problem:
    \"\"\"Create a division problem (a / b).\"\"\"
    return Problem(a, b, Operation.DIVIDE, a // b)


# =============================================================================
# WORLD 1: ADDITION ALPS (Levels 1-10)
# =============================================================================

LEVEL_1 = Level(
    number=1,
    world_number=1,
    level_in_world=1,
    name="Trailhead",
    level_type=LevelType.INTRO,
    problems=(
        add(1, 1),
        add(2, 1),
        add(3, 2),
        add(2, 2),
        add(1, 4),
        add(4, 3),
        add(5, 6),
        add(3, 3),
        add(4, 2),
        add(5, 5),
    ),
)

LEVEL_2 = Level(
    number=2,
    world_number=1,
    level_in_world=2,
    name="Foothills",
    level_type=LevelType.INTRO,
    problems=(
        add(2, 3),
        add(3, 2),
        add(4, 2),
        add(7, 5),
        add(9, 6),
        add(6, 4),
        add(4, 3),
        add(8, 8),
        add(3, 7),
        add(9, 7),
    ),
)

LEVEL_3 = Level(
    number=3,
    world_number=1,
    level_in_world=3,
    name="Snowy Path",
    level_type=LevelType.INTRO,
    problems=(
        add(8, 6),
        add(3, 9),
        add(2, 12),
        add(9, 7),
        add(7, 5),
        add(15, 8),
        add(4, 18),
        add(21, 9),
        add(24, 24),
        add(20, 10),
    ),
)

LEVEL_4 = Level(
    number=4,
    world_number=1,
    level_in_world=4,
    name="Alpine Meadow",
    level_type=LevelType.BUILD,
    problems=(
        add(16, 15),
        add(12, 20),
        add(8, 27),
        add(17, 9),
        add(6, 0),
        add(0, 34),
        add(26, 24),
        add(30, 20),
        add(50, 10),
        add(34, 23),
    ),
)

LEVEL_5 = Level(
    number=5,
    world_number=1,
    level_in_world=5,
    name="Mountain Trail",
    level_type=LevelType.BUILD,
    problems=(
        add(25, 25),
        add(13, 17),
        add(21, 18),
        add(19, 26),
        add(32, 16),
        add(15, 19),
        add(12, 31),
        add(17, 36),
        add(40, 40),
        add(50, 56),
    ),
)

LEVEL_6 = Level(
    number=6,
    world_number=1,
    level_in_world=6,
    name="Carry's Roost",
    level_type=LevelType.FRIEND,
    problems=(
        add(94, 17),
        add(27, 92),
        add(83, 72),
        add(26, 17),
        add(72, 20),
        add(54, 21),
        add(82, 84),
        add(27, 26),
        add(10, 70),
        add(14, 74),
    ),
)

LEVEL_7 = Level(
    number=7,
    world_number=1,
    level_in_world=7,
    name="Rocky Pass",
    level_type=LevelType.CHALLENGE,
    problems=(
        add(100, 300),
        add(150, 250),
        add(250, 250),
        add(145, 165),
        add(132, 249),
        add(180, 220),
        add(257, 278),
        add(190, 10),
        add(200, 700),
        add(123, 123),
    ),
)

LEVEL_8 = Level(
    number=8,
    world_number=1,
    level_in_world=8,
    name="Steep Cliffs",
    level_type=LevelType.CHALLENGE,
    problems=(
        add(200, 142),
        add(400, 298),
        add(220, 127),
        add(726, 176),
        add(178, 654),
        add(550, 259),
        add(163, 21),
        add(72, 764),
        add(400, 550),
        add(121, 212)
    ),
)

LEVEL_9 = Level(
    number=9,
    world_number=1,
    level_in_world=9,
    name="Final Ascent",
    level_type=LevelType.PREBOSS,
    problems=(
        add(100, 100),
        add(200, 300),
        add(250, 120),
        add(500, 400),
        add(320, 180),
        add(430, 170),
        add(880, 110),
        add(120, 530),
        add(780, 115),
        add(500, 300),
    ),
)

LEVEL_10 = Level(
    number=10,
    world_number=1,
    level_in_world=10,
    name="Summit's Challenge",
    level_type=LevelType.BOSS,
    time_limit=90,  # 90 seconds for 10 problems
    problems=(
        add(748, 129),
        add(73, 810),
        add(257, 180),
        add(128, 256),
        add(459, 123),
        add(100, 700),
        add(82, 27),
        add(64, 12),
        add(128, 412),
        add(499, 499),
    ),
)

# =============================================================================
# WORLD 2: SUBTRACTION SWAMP (Levels 11-20)
# =============================================================================

LEVEL_11 = Level(
    number=11,
    world_number=2,
    level_in_world=1,
    name="Marsh Edge",
    level_type=LevelType.INTRO,
    problems=(
        sub(3, 1),
        sub(4, 2),
        sub(5, 3),
        sub(4, 1),
        sub(5, 2),
        sub(6, 4),
        sub(5, 1),
        sub(6, 3),
        sub(7, 4),
        sub(8, 4),
    ),
)

LEVEL_12 = Level(
    number=12,
    world_number=2,
    level_in_world=2,
    name="Muddy Waters",
    level_type=LevelType.INTRO,
    problems=(
        sub(7, 3),
        sub(8, 2),
        sub(19, 6),
        sub(6, 6),
        sub(8, 5),
        sub(12, 7),
        sub(15, 5),
        sub(18, 8),
        sub(14, 7),
        sub(20, 10),
    ),
)

LEVEL_13 = Level(
    number=13,
    world_number=2,
    level_in_world=3,
    name="Foggy Path",
    level_type=LevelType.INTRO,
    problems=(
        sub(16, 8),
        sub(76, 8),
        sub(64, 32),
        sub(10, 6),
        sub(19, 17),
        sub(998, 997),
        sub(834, 832),
        sub(763, 760),
        sub(128, 16),
        sub(512, 256),
    ),
)

LEVEL_14 = Level(
    number=14,
    world_number=2,
    level_in_world=4,
    name="Lily Pads",
    level_type=LevelType.BUILD,
    problems=(
        sub(0, 1),
        sub(1, 3),
        sub(8, 16),
        sub(100, 200),
        sub(13, 17),
        sub(18, 22),
        sub(5, 110),
        sub(17, 127),
        sub(128, 543),
        sub(0, 888),
    ),
)

LEVEL_15 = Level(
    number=15,
    world_number=2,
    level_in_world=5,
    name="Cypress Grove",
    level_type=LevelType.BUILD,
    problems=(
        sub(10, 4),
        sub(11, 5),
        sub(12, 6),
        sub(13, 7),
        sub(14, 8),
        sub(15, 7),
        sub(12, 5),
        sub(14, 6),
        sub(16, 8),
        sub(17, 9),
    ),
)

LEVEL_16 = Level(
    number=16,
    world_number=2,
    level_in_world=6,
    name="Borrow's Hollow",
    level_type=LevelType.FRIEND,
    problems=(
        sub(10, 5),
        sub(11, 6),
        sub(12, 7),
        sub(13, 8),
        sub(11, 4),
        sub(14, 7),
        sub(12, 6),
        sub(15, 8),
        sub(13, 6),
        sub(16, 8),
    ),
)

LEVEL_17 = Level(
    number=17,
    world_number=2,
    level_in_world=7,
    name="Murky Depths",
    level_type=LevelType.CHALLENGE,
    problems=(
        sub(12, 5),
        sub(14, 6),
        sub(15, 7),
        sub(16, 8),
        sub(17, 9),
        sub(18, 9),
        sub(13, 5),
        sub(15, 6),
        sub(17, 8),
        sub(19, 10),
    ),
)

LEVEL_18 = Level(
    number=18,
    world_number=2,
    level_in_world=8,
    name="Tangled Vines",
    level_type=LevelType.CHALLENGE,
    problems=(
        sub(14, 6),
        sub(16, 7),
        sub(17, 8),
        sub(18, 9),
        sub(19, 10),
        sub(20, 9),
        sub(15, 6),
        sub(18, 8),
        sub(20, 10),
        sub(21, 11),
    ),
)

LEVEL_19 = Level(
    number=19,
    world_number=2,
    level_in_world=9,
    name="Swamp's Heart",
    level_type=LevelType.PREBOSS,
    problems=(
        sub(16, 7),
        sub(18, 9),
        sub(19, 10),
        sub(20, 11),
        sub(21, 12),
        sub(23, 11),
        sub(17, 8),
        sub(20, 9),
        sub(22, 11),
        sub(24, 12),
    ),
)

LEVEL_20 = Level(
    number=20,
    world_number=2,
    level_in_world=10,
    name="Minus's Throne",
    level_type=LevelType.BOSS,
    time_limit=90,  # 90 seconds for 10 problems
    problems=(
        sub(15, 7),
        sub(17, 8),
        sub(18, 9),
        sub(19, 10),
        sub(20, 11),
        sub(21, 12),
        sub(22, 11),
        sub(23, 12),
        sub(24, 12),
        sub(25, 13),
    ),
)

# =============================================================================
# WORLD 3: DIVISION DESERT (Levels 21-30)
# =============================================================================

LEVEL_21 = Level(
    number=21,
    world_number=3,
    level_in_world=1,
    name="Oasis Gate",
    level_type=LevelType.INTRO,
    problems=(
        div(2, 1),
        div(4, 2),
        div(6, 2),
        div(4, 1),
        div(6, 3),
        div(8, 2),
        div(3, 1),
        div(8, 4),
        div(9, 3),
        div(10, 2),
    ),
)

LEVEL_22 = Level(
    number=22,
    world_number=3,
    level_in_world=2,
    name="Sandy Trail",
    level_type=LevelType.INTRO,
    problems=(
        div(6, 2),
        div(8, 2),
        div(9, 3),
        div(10, 2),
        div(12, 3),
        div(12, 4),
        div(8, 4),
        div(10, 5),
        div(12, 2),
        div(15, 3),
    ),
)

LEVEL_23 = Level(
    number=23,
    world_number=3,
    level_in_world=3,
    name="Dune Ridge",
    level_type=LevelType.INTRO,
    problems=(
        div(8, 2),
        div(10, 2),
        div(12, 3),
        div(12, 4),
        div(14, 2),
        div(16, 4),
        div(9, 3),
        div(15, 5),
        div(16, 2),
        div(18, 3),
    ),
)

LEVEL_24 = Level(
    number=24,
    world_number=3,
    level_in_world=4,
    name="Scorpion Pass",
    level_type=LevelType.BUILD,
    problems=(
        div(10, 2),
        div(12, 3),
        div(14, 2),
        div(15, 3),
        div(16, 4),
        div(18, 2),
        div(12, 4),
        div(20, 4),
        div(18, 3),
        div(20, 5),
    ),
)

LEVEL_25 = Level(
    number=25,
    world_number=3,
    level_in_world=5,
    name="Mirage Valley",
    level_type=LevelType.BUILD,
    problems=(
        div(12, 3),
        div(14, 2),
        div(16, 4),
        div(18, 3),
        div(20, 4),
        div(21, 3),
        div(15, 5),
        div(24, 4),
        div(20, 5),
        div(24, 3),
    ),
)

LEVEL_26 = Level(
    number=26,
    world_number=3,
    level_in_world=6,
    name="Remainder's Rest",
    level_type=LevelType.FRIEND,
    problems=(
        div(10, 2),
        div(12, 3),
        div(15, 3),
        div(16, 4),
        div(18, 2),
        div(20, 4),
        div(14, 2),
        div(21, 3),
        div(24, 4),
        div(25, 5),
    ),
)

LEVEL_27 = Level(
    number=27,
    world_number=3,
    level_in_world=7,
    name="Sandstorm",
    level_type=LevelType.CHALLENGE,
    problems=(
        div(14, 2),
        div(18, 3),
        div(20, 4),
        div(21, 3),
        div(24, 4),
        div(27, 3),
        div(16, 4),
        div(28, 4),
        div(30, 5),
        div(32, 4),
    ),
)

LEVEL_28 = Level(
    number=28,
    world_number=3,
    level_in_world=8,
    name="Sunscorch",
    level_type=LevelType.CHALLENGE,
    problems=(
        div(18, 3),
        div(24, 4),
        div(25, 5),
        div(27, 3),
        div(28, 4),
        div(36, 4),
        div(20, 4),
        div(30, 5),
        div(35, 5),
        div(36, 6),
    ),
)

LEVEL_29 = Level(
    number=29,
    world_number=3,
    level_in_world=9,
    name="Pyramid's Shadow",
    level_type=LevelType.PREBOSS,
    problems=(
        div(24, 4),
        div(27, 3),
        div(30, 5),
        div(32, 4),
        div(35, 5),
        div(42, 6),
        div(28, 4),
        div(36, 4),
        div(40, 5),
        div(45, 5),
    ),
)

LEVEL_30 = Level(
    number=30,
    world_number=3,
    level_in_world=10,
    name="Sphinx's Riddles",
    level_type=LevelType.BOSS,
    time_limit=90,  # 90 seconds for 10 problems
    problems=(
        div(18, 3),
        div(24, 4),
        div(27, 3),
        div(28, 4),
        div(30, 5),
        div(35, 5),
        div(36, 4),
        div(40, 5),
        div(42, 6),
        div(48, 6),
    ),
)

# =============================================================================
# WORLD 4: MULTIPLICATION MEADOWS (Levels 31-40)
# =============================================================================

LEVEL_31 = Level(
    number=31,
    world_number=4,
    level_in_world=1,
    name="Flower Field",
    level_type=LevelType.INTRO,
    problems=(
        mul(2, 1),
        mul(2, 2),
        mul(3, 2),
        mul(2, 3),
        mul(2, 4),
        mul(3, 3),
        mul(2, 2),
        mul(4, 2),
        mul(3, 2),
        mul(5, 2),
    ),
)

LEVEL_32 = Level(
    number=32,
    world_number=4,
    level_in_world=2,
    name="Butterfly Path",
    level_type=LevelType.INTRO,
    problems=(
        mul(2, 3),
        mul(3, 3),
        mul(4, 2),
        mul(3, 4),
        mul(5, 2),
        mul(4, 3),
        mul(2, 4),
        mul(5, 3),
        mul(4, 4),
        mul(6, 2),
    ),
)

LEVEL_33 = Level(
    number=33,
    world_number=4,
    level_in_world=3,
    name="Clover Patch",
    level_type=LevelType.INTRO,
    problems=(
        mul(3, 3),
        mul(4, 3),
        mul(5, 3),
        mul(4, 4),
        mul(6, 2),
        mul(5, 4),
        mul(3, 4),
        mul(6, 3),
        mul(5, 5),
        mul(7, 2),
    ),
)

LEVEL_34 = Level(
    number=34,
    world_number=4,
    level_in_world=4,
    name="Honeybee Hive",
    level_type=LevelType.BUILD,
    problems=(
        mul(4, 3),
        mul(5, 3),
        mul(4, 4),
        mul(6, 3),
        mul(5, 4),
        mul(7, 3),
        mul(4, 5),
        mul(6, 4),
        mul(5, 5),
        mul(8, 3),
    ),
)

LEVEL_35 = Level(
    number=35,
    world_number=4,
    level_in_world=5,
    name="Dandelion Dell",
    level_type=LevelType.BUILD,
    problems=(
        mul(5, 4),
        mul(6, 3),
        mul(5, 5),
        mul(7, 3),
        mul(6, 4),
        mul(8, 3),
        mul(4, 6),
        mul(7, 4),
        mul(6, 5),
        mul(9, 3),
    ),
)

LEVEL_36 = Level(
    number=36,
    world_number=4,
    level_in_world=6,
    name="Times's Burrow",
    level_type=LevelType.FRIEND,
    problems=(
        mul(4, 4),
        mul(5, 4),
        mul(6, 3),
        mul(5, 5),
        mul(7, 3),
        mul(6, 4),
        mul(4, 5),
        mul(7, 4),
        mul(6, 5),
        mul(8, 4),
    ),
)

LEVEL_37 = Level(
    number=37,
    world_number=4,
    level_in_world=7,
    name="Pollen Storm",
    level_type=LevelType.CHALLENGE,
    problems=(
        mul(6, 4),
        mul(7, 4),
        mul(6, 5),
        mul(8, 4),
        mul(7, 5),
        mul(9, 4),
        mul(5, 6),
        mul(8, 5),
        mul(7, 6),
        mul(9, 5),
    ),
)

LEVEL_38 = Level(
    number=38,
    world_number=4,
    level_in_world=8,
    name="Rainbow Bridge",
    level_type=LevelType.CHALLENGE,
    problems=(
        mul(7, 5),
        mul(8, 4),
        mul(6, 6),
        mul(9, 4),
        mul(7, 6),
        mul(8, 6),
        mul(5, 7),
        mul(9, 5),
        mul(8, 7),
        mul(7, 7),
    ),
)

LEVEL_39 = Level(
    number=39,
    world_number=4,
    level_in_world=9,
    name="Final Bloom",
    level_type=LevelType.PREBOSS,
    problems=(
        mul(8, 5),
        mul(7, 6),
        mul(9, 5),
        mul(8, 6),
        mul(7, 7),
        mul(9, 6),
        mul(6, 7),
        mul(8, 7),
        mul(9, 7),
        mul(8, 8),
    ),
)

LEVEL_40 = Level(
    number=40,
    world_number=4,
    level_in_world=10,
    name="Calculata's Garden",
    level_type=LevelType.BOSS,
    time_limit=90,  # 90 seconds for 10 problems
    problems=(
        mul(7, 5),
        mul(8, 5),
        mul(6, 6),
        mul(9, 5),
        mul(7, 6),
        mul(8, 6),
        mul(7, 7),
        mul(9, 6),
        mul(8, 7),
        mul(9, 9),
    ),
)

# All levels in order
LEVELS = [
    # World 1: Addition Alps
    LEVEL_1,
    LEVEL_2,
    LEVEL_3,
    LEVEL_4,
    LEVEL_5,
    LEVEL_6,
    LEVEL_7,
    LEVEL_8,
    LEVEL_9,
    LEVEL_10,
    # World 2: Subtraction Swamp
    LEVEL_11,
    LEVEL_12,
    LEVEL_13,
    LEVEL_14,
    LEVEL_15,
    LEVEL_16,
    LEVEL_17,
    LEVEL_18,
    LEVEL_19,
    LEVEL_20,
    # World 3: Division Desert
    LEVEL_21,
    LEVEL_22,
    LEVEL_23,
    LEVEL_24,
    LEVEL_25,
    LEVEL_26,
    LEVEL_27,
    LEVEL_28,
    LEVEL_29,
    LEVEL_30,
    # World 4: Multiplication Meadows
    LEVEL_31,
    LEVEL_32,
    LEVEL_33,
    LEVEL_34,
    LEVEL_35,
    LEVEL_36,
    LEVEL_37,
    LEVEL_38,
    LEVEL_39,
    LEVEL_40,
]


def get_level(level_num: int) -> Level | None:
    \"\"\"Get level by number. Returns None if level doesn't exist.\"\"\"
    for level in LEVELS:
        if level.number == level_num:
            return level
    return None


def get_next_level(current_level: int) -> Level | None:
    \"\"\"Get the next level after the current one. Returns None if no more levels.\"\"\"
    return get_level(current_level + 1)


def get_total_levels() -> int:
    \"\"\"Return total number of levels available.\"\"\"
    return len(LEVELS)


def get_levels_for_world(world_num: int) -> list[Level]:
    \"\"\"Get all levels in a specific world.\"\"\"
    return [level for level in LEVELS if level.world_number == world_num]

"""

exec(_code_flashy_core_levels, sys.modules["flashy.core.levels"].__dict__)

# === flashy.core.flow ===
# Create module
_mod = ModuleType("flashy.core.flow")
_mod.__package__ = "flashy.core"
sys.modules["flashy.core.flow"] = _mod
setattr(sys.modules["flashy.core"], "flow", _mod)

_code_flashy_core_flow = """\
\"\"\"Game flow state machine - defines screen transitions.

This module owns all navigation logic. Screens emit events, and GameFlow
determines what screen to show next. This ensures consistent game flow
across all platforms (TUI, web, iOS).
\"\"\"

from dataclasses import dataclass
from enum import Enum, auto
from typing import Any

from flashy.core.levels import get_level
from flashy.core.models import PlayerProgress
from flashy.core.worlds import get_world


class Screen(Enum):
    \"\"\"All possible screens in the game.\"\"\"

    PLAYER_SELECT = auto()
    NEW_PLAYER = auto()
    INTRO = auto()
    WORLD_INTRO = auto()
    WORLD_MAP = auto()
    FRIEND_MEET = auto()
    BOSS_INTRO = auto()
    GAMEPLAY = auto()
    RESULT = auto()
    BOSS_VICTORY = auto()
    GAME_COMPLETE = auto()


@dataclass(frozen=True)
class ScreenRequest:
    \"\"\"Request to show a specific screen with parameters.\"\"\"

    screen: Screen
    params: dict[str, Any]

    def __repr__(self) -> str:
        return f"ScreenRequest({self.screen.name}, {self.params})"


# --- Events that trigger screen transitions ---


@dataclass(frozen=True)
class GameEvent:
    \"\"\"Base class for game events.\"\"\"

    pass


@dataclass(frozen=True)
class AppStarted(GameEvent):
    \"\"\"App has started.\"\"\"

    pass


@dataclass(frozen=True)
class PlayerSelected(GameEvent):
    \"\"\"Player selected from player list.\"\"\"

    player_name: str
    is_new_player: bool  # True if this is a brand new player


@dataclass(frozen=True)
class NewPlayerCreated(GameEvent):
    \"\"\"New player profile created.\"\"\"

    player_name: str


@dataclass(frozen=True)
class IntroDismissed(GameEvent):
    \"\"\"Intro story screen dismissed.\"\"\"

    player_name: str


@dataclass(frozen=True)
class WorldIntroDismissed(GameEvent):
    \"\"\"World intro story screen dismissed.\"\"\"

    player_name: str
    world_number: int


@dataclass(frozen=True)
class LevelSelected(GameEvent):
    \"\"\"Level selected from world map.\"\"\"

    player_name: str
    level_number: int


@dataclass(frozen=True)
class FriendMeetDismissed(GameEvent):
    \"\"\"Friend meet story screen dismissed.\"\"\"

    player_name: str
    level_number: int


@dataclass(frozen=True)
class BossIntroDismissed(GameEvent):
    \"\"\"Boss intro story screen dismissed.\"\"\"

    player_name: str
    level_number: int


@dataclass(frozen=True)
class LevelCompleted(GameEvent):
    \"\"\"Level gameplay completed.\"\"\"

    player_name: str
    level_number: int
    stars: int
    is_new_best: bool
    correct: int
    total: int
    score: int
    best_streak: int


@dataclass(frozen=True)
class ResultContinue(GameEvent):
    \"\"\"Continue button pressed on result screen.\"\"\"

    player_name: str
    level_number: int
    stars: int


@dataclass(frozen=True)
class ResultReplay(GameEvent):
    \"\"\"Replay button pressed on result screen.\"\"\"

    player_name: str
    level_number: int


@dataclass(frozen=True)
class BossVictoryDismissed(GameEvent):
    \"\"\"Boss victory screen dismissed.\"\"\"

    player_name: str
    world_number: int


@dataclass(frozen=True)
class GameCompleteDismissed(GameEvent):
    \"\"\"Game complete screen dismissed.\"\"\"

    pass


class GameFlow:
    \"\"\"Determines screen transitions based on game events.

    This is the single source of truth for game navigation. All platforms
    should use this to ensure consistent behavior.
    \"\"\"

    def handle(
        self, event: GameEvent, progress: PlayerProgress | None = None
    ) -> ScreenRequest:
        \"\"\"Handle a game event and return the next screen to show.

        Args:
            event: The game event that occurred.
            progress: Player's current progress (needed for some transitions).

        Returns:
            ScreenRequest indicating which screen to show next.
        \"\"\"
        if isinstance(event, AppStarted):
            return ScreenRequest(Screen.PLAYER_SELECT, {})

        if isinstance(event, PlayerSelected):
            if event.is_new_player:
                return ScreenRequest(Screen.NEW_PLAYER, {})
            # Existing player - check if they've played before
            if progress and progress.get_highest_unlocked() > 1:
                # Return to world map
                return ScreenRequest(
                    Screen.WORLD_MAP,
                    {"player_name": event.player_name},
                )
            # New-ish player, show intro
            return ScreenRequest(
                Screen.INTRO,
                {"player_name": event.player_name},
            )

        if isinstance(event, NewPlayerCreated):
            return ScreenRequest(
                Screen.INTRO,
                {"player_name": event.player_name},
            )

        if isinstance(event, IntroDismissed):
            return ScreenRequest(
                Screen.WORLD_INTRO,
                {"player_name": event.player_name, "world_number": 1},
            )

        if isinstance(event, WorldIntroDismissed):
            return ScreenRequest(
                Screen.WORLD_MAP,
                {"player_name": event.player_name, "world_number": event.world_number},
            )

        if isinstance(event, LevelSelected):
            level = get_level(event.level_number)
            if level is None:
                return ScreenRequest(
                    Screen.WORLD_MAP,
                    {"player_name": event.player_name},
                )

            # Check for story screens before certain levels
            if level.level_in_world == 6:
                # Friend meet before level 6
                return ScreenRequest(
                    Screen.FRIEND_MEET,
                    {
                        "player_name": event.player_name,
                        "world_number": level.world_number,
                        "level_number": event.level_number,
                    },
                )
            if level.level_in_world == 10:
                # Boss intro before level 10
                return ScreenRequest(
                    Screen.BOSS_INTRO,
                    {
                        "player_name": event.player_name,
                        "world_number": level.world_number,
                        "level_number": event.level_number,
                    },
                )

            # Regular level - go straight to gameplay
            return ScreenRequest(
                Screen.GAMEPLAY,
                {"player_name": event.player_name, "level_number": event.level_number},
            )

        if isinstance(event, FriendMeetDismissed):
            return ScreenRequest(
                Screen.GAMEPLAY,
                {"player_name": event.player_name, "level_number": event.level_number},
            )

        if isinstance(event, BossIntroDismissed):
            return ScreenRequest(
                Screen.GAMEPLAY,
                {"player_name": event.player_name, "level_number": event.level_number},
            )

        if isinstance(event, LevelCompleted):
            return ScreenRequest(
                Screen.RESULT,
                {
                    "player_name": event.player_name,
                    "level_number": event.level_number,
                    "stars": event.stars,
                    "is_new_best": event.is_new_best,
                    "correct": event.correct,
                    "total": event.total,
                    "score": event.score,
                    "best_streak": event.best_streak,
                },
            )

        if isinstance(event, ResultContinue):
            level = get_level(event.level_number)
            if level and level.level_in_world == 10 and event.stars >= 2:
                # Beat the boss! Show victory screen
                return ScreenRequest(
                    Screen.BOSS_VICTORY,
                    {
                        "player_name": event.player_name,
                        "world_number": level.world_number,
                    },
                )

            # Regular continue - back to world map
            if event.stars >= 2:
                next_level = event.level_number + 1
            else:
                next_level = event.level_number
            return ScreenRequest(
                Screen.WORLD_MAP,
                {"player_name": event.player_name, "selected_level": next_level},
            )

        if isinstance(event, ResultReplay):
            return ScreenRequest(
                Screen.GAMEPLAY,
                {"player_name": event.player_name, "level_number": event.level_number},
            )

        if isinstance(event, BossVictoryDismissed):
            next_world = get_world(event.world_number + 1)
            if next_world:
                # More worlds to explore
                return ScreenRequest(
                    Screen.WORLD_INTRO,
                    {
                        "player_name": event.player_name,
                        "world_number": event.world_number + 1,
                    },
                )
            # All worlds complete!
            return ScreenRequest(
                Screen.GAME_COMPLETE,
                {"player_name": event.player_name},
            )

        if isinstance(event, GameCompleteDismissed):
            return ScreenRequest(Screen.PLAYER_SELECT, {})

        # Unknown event - return to player select as fallback
        return ScreenRequest(Screen.PLAYER_SELECT, {})

"""

exec(_code_flashy_core_flow, sys.modules["flashy.core.flow"].__dict__)

# === flashy.game ===
# Create module
_mod = ModuleType("flashy.game")
_mod.__package__ = "flashy"
sys.modules["flashy.game"] = _mod
setattr(sys.modules["flashy"], "game", _mod)

_code_flashy_game = """\
\"\"\"Game controller - manages game lifecycle for a level attempt.\"\"\"

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

from flashy.core.levels import Level, get_level
from flashy.core.models import LevelResult, ProblemResult
from flashy.core.number_parser import is_fuzzy_match
from flashy.core.problems import Problem
from flashy.core.scoring import calculate_score, calculate_stars, get_streak_multiplier

if TYPE_CHECKING:
    from flashy.storage.protocol import StorageBackend


@dataclass
class AnswerFeedback:
    \"\"\"Feedback from submitting an answer.\"\"\"

    is_correct: bool
    points_earned: int
    correct_answer: int
    streak: int
    streak_multiplier: float


class GameController:
    \"\"\"Controls game lifecycle for a single level attempt.

    The controller owns all game state and logic:
    - Serving problems
    - Receiving and validating answers
    - Calculating scores with streak bonuses
    - Saving progress and history

    The UI should just display controller state and route input.
    \"\"\"

    def __init__(
        self,
        player_name: str,
        level_number: int,
        storage: StorageBackend | None = None,
    ) -> None:
        self.player_name = player_name
        self.level_number = level_number
        self._storage = storage  # Lazy load if None
        level = get_level(level_number)
        if level is None:
            raise ValueError(f"Level {level_number} not found")
        self.level: Level = level
        self.problem_index = 0
        self.results: list[ProblemResult] = []
        self.total_score = 0
        self.streak = 0
        self.best_streak = 0
        self.total_time = 0.0

    @property
    def storage(self) -> StorageBackend:
        \"\"\"Get the storage backend, using default if not provided.\"\"\"
        if self._storage is None:
            from flashy.storage import get_default_storage

            self._storage = get_default_storage()
        return self._storage

    @property
    def current_problem(self) -> Problem | None:
        \"\"\"Get current problem, or None if complete.\"\"\"
        if self.problem_index >= len(self.level.problems):
            return None
        return self.level.problems[self.problem_index]

    @property
    def is_complete(self) -> bool:
        \"\"\"Check if all problems have been answered.\"\"\"
        return self.problem_index >= len(self.level.problems)

    @property
    def correct_count(self) -> int:
        \"\"\"Count of correct answers so far.\"\"\"
        return sum(1 for r in self.results if r.is_correct)

    @property
    def problems_answered(self) -> int:
        \"\"\"Number of problems answered so far.\"\"\"
        return len(self.results)

    @property
    def total_problems(self) -> int:
        \"\"\"Total number of problems in this level.\"\"\"
        return len(self.level.problems)

    @property
    def time_limit(self) -> int | None:
        \"\"\"Time limit in seconds for this level, or None if untimed.\"\"\"
        return self.level.time_limit

    @property
    def is_timed(self) -> bool:
        \"\"\"Check if this level has a time limit (boss battle).\"\"\"
        return self.level.time_limit is not None

    def time_remaining(self, elapsed: float) -> float:
        \"\"\"Get remaining time given elapsed wall-clock seconds.

        Args:
            elapsed: Seconds since level started

        Returns:
            Remaining seconds, or float('inf') if untimed
        \"\"\"
        if self.level.time_limit is None:
            return float("inf")
        return max(0.0, self.level.time_limit - elapsed)

    def is_time_expired(self, elapsed: float) -> bool:
        \"\"\"Check if time has expired.

        Args:
            elapsed: Seconds since level started

        Returns:
            True if timed level and time has run out
        \"\"\"
        if self.level.time_limit is None:
            return False
        return elapsed >= self.level.time_limit

    def submit_answer(self, answer: int | None, time_taken: float) -> AnswerFeedback:
        \"\"\"Submit answer for current problem.

        Args:
            answer: The answer given (None if skipped)
            time_taken: Time in seconds to answer

        Returns:
            AnswerFeedback with result details
        \"\"\"
        problem = self.current_problem
        if problem is None:
            raise ValueError("No current problem - game is complete")

        is_correct = answer is not None and is_fuzzy_match(answer, problem.answer)

        # Update streak
        if is_correct:
            self.streak += 1
            self.best_streak = max(self.best_streak, self.streak)
        else:
            self.streak = 0

        # Calculate score using scoring.py
        points = calculate_score(time_taken, is_correct, self.streak)
        self.total_score += points
        self.total_time += time_taken

        # Record result
        self.results.append(
            ProblemResult(
                problem=problem.display(),
                correct_answer=problem.answer,
                given_answer=answer,
                is_correct=is_correct,
                time_seconds=time_taken,
                points=points,
            )
        )

        # Advance to next problem
        self.problem_index += 1

        return AnswerFeedback(
            is_correct=is_correct,
            points_earned=points,
            correct_answer=problem.answer,
            streak=self.streak,
            streak_multiplier=get_streak_multiplier(self.streak),
        )

    def finish(self) -> tuple[int, bool]:
        \"\"\"Finish the level. Saves progress and history.

        Returns:
            Tuple of (stars earned, is_new_best)
        \"\"\"
        stars = calculate_stars(
            self.correct_count, self.total_problems, self.total_time
        )

        # Save progress via storage backend
        progress = self.storage.load_progress(self.player_name)
        old_stars = progress.get_stars(self.level_number)
        progress.set_stars(self.level_number, stars)
        self.storage.save_progress(self.player_name, progress)

        # Log session history via storage backend
        self.storage.log_session(
            LevelResult(
                level_number=self.level_number,
                level_name=self.level.name,
                total_score=self.total_score,
                correct_count=self.correct_count,
                total_problems=self.total_problems,
                best_streak=self.best_streak,
                total_time_seconds=self.total_time,
                problems=self.results,
            )
        )

        return stars, stars > old_stars

    # --- Cheat methods for dev/testing ---

    def cheat_pass_all(self) -> None:
        \"\"\"Complete all remaining problems with correct answers.

        Useful for testing progression without playing through levels.
        \"\"\"
        while not self.is_complete:
            if problem := self.current_problem:
                self.submit_answer(problem.answer, time_taken=1.0)

    def cheat_fail_all(self) -> None:
        \"\"\"Complete all remaining problems with wrong answers.

        Useful for testing failure states.
        \"\"\"
        while not self.is_complete:
            if problem := self.current_problem:
                self.submit_answer(problem.answer + 999, time_taken=1.0)

"""

exec(_code_flashy_game, sys.modules["flashy.game"].__dict__)

# === flashy.platforms.web.storage ===
# Create module
_mod = ModuleType("flashy.platforms.web.storage")
_mod.__package__ = "flashy.platforms.web"
sys.modules["flashy.platforms.web.storage"] = _mod
setattr(sys.modules["flashy.platforms.web"], "storage", _mod)

_code_flashy_platforms_web_storage = """\
\"\"\"Web storage backend using browser localStorage via Pyodide.\"\"\"

import json
from dataclasses import asdict
from datetime import datetime

from flashy.core.models import LevelResult, PlayerProgress

# When running in Pyodide, js module gives access to browser APIs
try:
    from js import localStorage  # type: ignore[import-not-found]
except ImportError:
    # Fallback for testing outside browser
    localStorage = None


class WebStorage:
    \"\"\"Storage backend using browser localStorage.

    Data is stored as JSON strings with the following keys:
    - flashy_players: List of player names
    - flashy_player_{name}: Player progress JSON
    - flashy_history: Array of session log entries
    \"\"\"

    def _get(self, key: str) -> str | None:
        \"\"\"Get a value from localStorage.\"\"\"
        if localStorage is None:
            return None
        return localStorage.getItem(key)

    def _set(self, key: str, value: str) -> None:
        \"\"\"Set a value in localStorage.\"\"\"
        if localStorage is None:
            return
        localStorage.setItem(key, value)

    def load_progress(self, player_name: str) -> PlayerProgress:
        \"\"\"Load player progress from localStorage.\"\"\"
        data_str = self._get(f"flashy_player_{player_name}")
        if not data_str:
            return PlayerProgress()

        try:
            data = json.loads(data_str)
            stars = {int(k): v for k, v in data.get("stars", {}).items()}
            return PlayerProgress(stars=stars)
        except (json.JSONDecodeError, KeyError):
            return PlayerProgress()

    def save_progress(self, player_name: str, progress: PlayerProgress) -> None:
        \"\"\"Save player progress to localStorage.\"\"\"
        # Ensure player is in the players list
        players = self.list_players()
        if player_name not in players:
            players.append(player_name)
            self._set("flashy_players", json.dumps(players))

        # Save progress
        data = {"stars": progress.stars}
        self._set(f"flashy_player_{player_name}", json.dumps(data))

    def log_session(self, result: LevelResult) -> None:
        \"\"\"Append a session result to history.\"\"\"
        history_str = self._get("flashy_history") or "[]"
        try:
            history = json.loads(history_str)
        except json.JSONDecodeError:
            history = []

        entry = {
            "timestamp": datetime.now().isoformat(),
            "level_number": result.level_number,
            "level_name": result.level_name,
            "score": result.total_score,
            "correct": result.correct_count,
            "total": result.total_problems,
            "best_streak": result.best_streak,
            "time_seconds": result.total_time_seconds,
            "problems": [asdict(p) for p in result.problems],
        }

        history.append(entry)
        self._set("flashy_history", json.dumps(history))

    def log_speech_recognition(
        self,
        raw_transcript: str,
        parsed_number: int | None,
        expected: int | None,
        matched: bool,
    ) -> None:
        \"\"\"Log speech recognition (stored in memory only for web).\"\"\"
        # For web, we might just console.log this or skip
        pass

    def list_players(self) -> list[str]:
        \"\"\"List all player names.\"\"\"
        players_str = self._get("flashy_players")
        if not players_str:
            return []
        try:
            return json.loads(players_str)
        except json.JSONDecodeError:
            return []

    def player_exists(self, player_name: str) -> bool:
        \"\"\"Check if a player exists.\"\"\"
        return player_name in self.list_players()

"""

exec(_code_flashy_platforms_web_storage, sys.modules["flashy.platforms.web.storage"].__dict__)
